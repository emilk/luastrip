#pragma once

#include "lexer.hpp"

struct Statement;
struct Expression;
struct TypeNode;
struct FunType;


// TODO: use custom linked list instead
typedef std::vector<Statement*,  STLAllocator<Statement*> > StatementList;
typedef std::vector<Expression*, STLAllocator<Expression*>> ExprList;
typedef std::vector<TypeNode*,   STLAllocator<TypeNode*>>   TypeNodeList;
//typedef std::forward_list<Statement*,  STLAllocator<Statement*> > StatementList;
//typedef std::forward_list<Expression*, STLAllocator<Expression*>> ExprList;
//typedef std::forward_list<TypeNode*,   STLAllocator<TypeNode*>>   TypeNodeList;

// -----------------------------------------------

enum class Scoping {
	Implicit, //        function() ...
	Local,    // local  function() ...   local  x =
	Global,   // global function() ...   global x =
	Var       //                         var    x = ...
};

// -----------------------------------------------

struct StatList
{
	StatList(Allocator& alloc) : stats(alloc) {
	}
	StatementList stats;
};

struct ASTNode
{
	ASTNode(TokList* tl, Allocator&) : tokens(tl) {}
	virtual ~ASTNode() {};  // Make ASTNode polymorthic for RTTI
	
	TokList* tokens;
	bool     synthetic = false;  // if true: node generated by e.g.  +=
};

struct Statement : ASTNode
{
	using ASTNode::ASTNode;
};

struct Expression : ASTNode
{
	using ASTNode::ASTNode;
};

struct TypeList : ASTNode
{
	TypeList(TokList* tl, Allocator& alloc) : ASTNode(tl, alloc), types(alloc) {
	}
	TypeNodeList types;
};

struct TypeNode : ASTNode
{
	using ASTNode::ASTNode;
};


// -----------------------------------------------
// Expressions

struct UnopExpr : Expression
{
	using Expression::Expression;
	T            op;
	Expression*  rhs;
};

struct BinopExpr : Expression
{
	using Expression::Expression;
	Expression*  lhs;
	T            op;
	Expression*  rhs;
};

// The first and only tokens holds the details of these:

struct RawTokenExpr : Expression {
	using Expression::Expression;
};

struct IntegerExpr : RawTokenExpr {
	using RawTokenExpr::RawTokenExpr;
};

struct NumberExpr : RawTokenExpr {
	using RawTokenExpr::RawTokenExpr;
};

struct StringExpr : RawTokenExpr {
	using RawTokenExpr::RawTokenExpr;
};

struct NilExpr : RawTokenExpr {
	using RawTokenExpr::RawTokenExpr;
};

struct FalseExpr : RawTokenExpr {
	using RawTokenExpr::RawTokenExpr;
};

struct TrueExpr : RawTokenExpr {
	using RawTokenExpr::RawTokenExpr;
};

struct ExternExpr : RawTokenExpr {
	using RawTokenExpr::RawTokenExpr;
};

struct VarArgsExpr : RawTokenExpr {
	using RawTokenExpr::RawTokenExpr;
};

struct ConstructorExpr : Expression {
	// Table constructor
	struct Entry {
		const Token* key_ident = nullptr;  // key_ident = value
		Expression*  key_expr  = nullptr;  // [key_expr] = value
		Expression*  value     = nullptr;  // the above, or list value
	};
	
	ConstructorExpr(TokList* tokens, Allocator& alloc) : Expression(tokens, alloc), entries(alloc) {
	}
	
	std::vector<Entry, STLAllocator<Entry>> entries;
};

struct MemberExpr : Expression {
	using Expression::Expression;
	
	Expression*  base;
	const Token* ident;
};

// base.ident
struct MemberExprDot : MemberExpr {
	using MemberExpr::MemberExpr;
};

// base:ident
struct MemberExprColon : MemberExpr {
	using MemberExpr::MemberExpr;
};

// base[index]
struct IndexExpr : Expression {
	using Expression::Expression;
	Expression* base;
	Expression* index;
};

struct CallExpr : Expression {
	CallExpr(TokList* tokens, Allocator& alloc) : Expression(tokens, alloc), args(alloc) {
	}
	
	Expression* base;
	ExprList    args;
};

// base(args)
struct ParenCallExpr : CallExpr {
	using CallExpr::CallExpr;
};

// base"args[0]"
struct StringCallExpr : CallExpr {
	using CallExpr::CallExpr;
};

// base{args[0]}
struct TableCallExpr : CallExpr {
	using CallExpr::CallExpr;
};

// (inner)
struct ParenExpr : Expression {
	using Expression::Expression;
	Expression* inner;
};

// id
struct IdExpr : Expression {
	using Expression::Expression;
	const Token* ident;
};

// foo : type
struct CastExpr : Expression {
	using Expression::Expression;
	Expression* expr;
	TypeNode*   type;
};

// function type body end
struct LambdaExpr : Expression {
	using Expression::Expression;
	FunType*  type;
	StatList* body;
};


// -----------------------------------------------
// Statements

struct IfStat : Statement
{
	struct Clause {
		// [else]if cond then body end
		// else body end
		Expression* cond;
		StatList*   body;
	};
	
	IfStat(TokList* tokens, Allocator& alloc) : Statement(tokens, alloc), clauses(alloc) {
		clauses.reserve(2);
	}
	
	std::vector<Clause, STLAllocator<Clause>> clauses;
};

struct WhileStat : Statement
{
	using Statement::Statement;
	Expression* cond;
	StatList*   body;
};

struct RepeatUntilStat : Statement
{
	using Statement::Statement;
	StatList*   body;
	Expression* cond;
};

struct DoStat : Statement
{
	using Statement::Statement;
	StatList*   body;
};

struct NumericForStat : Statement
{
	using Statement::Statement;
	// for it_name = begin,end[,step] do body end
	const Token* it_name;
	Expression*  begin;
	Expression*  end;
	Expression*  step;
	StatList*    body;
};

struct GenericForStat : Statement
{
	GenericForStat(TokList* tokens, Allocator& alloc) : Statement(tokens, alloc), var_names(alloc), generators(alloc) {
		var_names.reserve(2);
		generators.reserve(1);
	}
	
	// for var_names in genereators do body end
	TokList   var_names;
	ExprList  generators;
	StatList* body;
};


struct ReturnStat : Statement
{
	ReturnStat(TokList* tokens, Allocator& alloc)
	: Statement(tokens, alloc), arguments(alloc) {
	}
	ExprList arguments;
};


struct BreakStat : Statement
{
	using Statement::Statement;
};


struct GotoStat : Statement
{
	using Statement::Statement;
	const Token* label;
};


struct LabelStat : Statement
{
	using Statement::Statement;
	const Token* label;
};

// lhs = rhs
struct AssignmentStat : Statement
{
	AssignmentStat(TokList* tokens, Allocator& alloc)
	: Statement(tokens, alloc),lhs(alloc), rhs(alloc) {
	}
	ExprList lhs, rhs;
};

// local|global|var name_list [= init_list]
struct VarDeclStat : Statement
{
	VarDeclStat(TokList* tokens, Allocator& alloc)
	: Statement(tokens, alloc), name_list(alloc), init_list(alloc) {
	}
	Scoping  scoping;
	TokList  name_list;
	ExprList init_list;
};

// [scoping] typedef [namespace_name.]type_name [: base_types] [= type]
struct TypedefStat : Statement
{
	TypedefStat(TokList* tokens, Allocator& alloc)
	: Statement(tokens, alloc), base_types(alloc) {
	}
	
	const Token* namespace_name;
	const Token* type_name;
	TypeNodeList base_types;
	TypeNode*    type = nullptr;
};

// [scoping] class name = rhs
struct ClassStat : Statement
{
	using Statement::Statement;
	Scoping      scoping;
	const Token* name;
	Expression*  rhs;
};

struct CallStat : Statement
{
	using Statement::Statement;
	CallExpr* expr;
};

// scoping function name_expr type body end
struct FunDeclStat : Statement {
	using Statement::Statement;
	Scoping     scoping;
	Expression* name_expr;
	FunType*    type;
	StatList*   body;
};

// Just so we can append the last white when outputting
struct EOFStat : Statement
{
	using Statement::Statement;
};

// -----------------------------------------------
// Types:

struct IntegerType : TypeNode {
	using TypeNode::TypeNode;
};

struct NumberType : TypeNode {
	using TypeNode::TypeNode;
};

struct StringType : TypeNode {
	using TypeNode::TypeNode;
};

struct NilType : TypeNode {
	using TypeNode::TypeNode;
};

struct FalseType : TypeNode {
	using TypeNode::TypeNode;
};

struct TrueType : TypeNode {
	using TypeNode::TypeNode;
};

struct ExternType : TypeNode {
	using TypeNode::TypeNode;
};

// (inner)
struct ParenType : TypeNode
{
	using TypeNode::TypeNode;
	TypeNode* inner;
};

// inner?
struct NilableType : TypeNode
{
	using TypeNode::TypeNode;
	TypeNode* inner;
};

// lhs or rhs
struct OrType : TypeNode
{
	using TypeNode::TypeNode;
	TypeNode* lhs;
	TypeNode* rhs;
};

// [type]
struct ListType : TypeNode
{
	using TypeNode::TypeNode;
	TypeNode* type;
};

// { name : type }
struct ObjectType : TypeNode
{
	ObjectType(TokList* tokens, Allocator& alloc)
	: TypeNode(tokens, alloc), names(alloc), types(alloc) {
	}
	
	TokList      names;
	TypeNodeList types;
};

// { key => value }
struct MapType : TypeNode
{
	using TypeNode::TypeNode;
	TypeNode* key;
	TypeNode* value;
};

// { key }
struct SetType : TypeNode
{
	using TypeNode::TypeNode;
	TypeNode* type;
};

// [var_name.]name
struct IdentifierType : TypeNode
{
	using TypeNode::TypeNode;
	const Token* var_name;
	const Token* name;
};


// (arg : type, ... : type) -> ret, ...
struct FunType : TypeNode
{
	FunType(TokList* tokens, Allocator& alloc)
	: TypeNode(tokens, alloc), args(alloc) {
	}
	
	struct Arg {
		const Token* name; // nullptr, Identifier or Ellipsis
		TypeNode*    type; // nullptr or Type
	};
	typedef std::vector<Arg, STLAllocator<Arg>> ArgList;
	
	ArgList   args;
	TypeList* rets;  // Can be nil
};
